  COM S 327 NOTES
  KEY:
    Ω: (alt-z), code
    ∆: (alt-j), important line

--------------------------------------------------------------------------------------------

  *** Notes 1/11/17
    ** Command line arguments for compiling c in linux
      * gcc –Wall –Werror –ggdb –o
      * -Werror tells the compiler to treat warnings like errors, which we want
      * -Wall turns on most warnings, including ones that don’t show up without the flag

  *** Notes 1/18/17
    ** Rock hardness from 1 – 254
      * Rooms have hardness 0
      * Outside border has hardness 255
    ** Seeding the random number generator
      * To get the seed: seed = time(NULL)
      * Initialize rand: srand(seed) --> only call this ONCE
      * To get a rand between 1 and 100: rand() % 100 + 1
      * rand between -100 and 100: (signed) rand() % 201 - 100

  *** Notes 01/23/17
    ** Array Stuffs & Casting
      * array[5] is stored at the address in array + 5 times the size of an int
      * matrix[2][1] is stored at 2x size of a row + 1x the size of an item
      * (array + 5) is the address of array[5]
      * ((int *) martix) + (2 * 4) + 1 -- 2 from the row num & 4 is the number of items
      in the row & 1 is the position in the row -- is the address of matrix[2][1]
∆     * COMPILER AUTO MULTIPLIES BY THE SIZE OF THE ITEM
      * (array + 5) == &array[5]
∆     * (*(array + 5) == array[5]) -- entirety put in parenthesis bc my bullets are same as pointer
      * (* --> dereference operator) && (& --> address operator)
    ** STRUCTS
Ω     * CODE OPEN
        {
          struct room {
            int x_pos;
            int y_pos;
            int x_size;
            int y_size;
          };
        }
Ω     * CODE CLOSE
      * Work similar to classes in Java
∆     * p->x_size = 5 is equivalent to (*p).x_size = 5
      The first is preferable
      * It's faster to pass structs by address vs value
      * Dynamic storage is allocated with malloc(3). Anytime you allocate something,
      you must return it to the system with free(3)
Ω     * CODE OPEN
      {
        #indef STACK_H
        # define STACK_H

        //type 1
        typedef struct stack_node {
          int value;
          struct stack_node *next;
        } stack_node_t;

        //type 2
        struct stack_node {
          int value;
          struct stack_node *next;
        };

        typedef struct stack_node stack_node_t;

        struct stack {
          int size;
          stack_node_t *top;
        } stack_t;

        $endif
      }
Ω     * CODE CLOSE
